Section2:

Installation of docker on different os.

To removed the all stoped container,use below commad

docker container prune

=======================================================================================================

Section3: Basic docker containers.

container life:
if no process running inside the container,docker will terminate the container.

Busybox image:
Busybox is multi-call binary, that combined  many common unix utilities inti small execultable,mean busybox single executable contain the many executable of unix utility.
 
Busybox is not a fully-featured linux os.have a set of linux utilities.it don't have any os info (cat /etc/*release*)

Almost all common commands of unix(linux is taken features of unix and built,so use busybox for basic linux operation) are available in the busybox image.it is very small in size compare other os images(ubuntu,redhat)

Alpine image: it is based on the busybox image and musl libc().it is almost full feature of linux system.You can able to install the additional packages using apk

Enter into container and do ls -la /bin -->all executables are pointing to busybox executable in bin path.

=======================================================================================================

Section4: Port mapping and volume mount using nginx image

docker pull nginx

Port mapping:
docker run -p 8081:80 -d --name nginx_test_1 nginx

the content or anything is serving on 81 port are mapping into 8081 port of host machine. 
  
    -p host_port:container_port

volume mount:
=============
Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. 
While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker. 

The bind mounts are -v and --mount.

The biggest difference is that the -v syntax combines all the options together in one field, while the --mount syntax separates them.

-v or --volume: Consists of three fields, separated by colon characters (:). The fields must be in the correct order, and the meaning of each field isn't immediately obvious.

syantax:
-v host_path:container_path:options with commas seperated

docker run -d \
  --name nginxtest \
  -p 8083:80
  -v path_in_host_machine:/usr/share/nginx/html:ro,local \
  nginx:latest

--mount: 
Consists of multiple key-value pairs, separated by commas and each consisting of a <key>=<value> tuple.
but the order of the keys isn't important.

flags are:
  *The "type" of the mount, which can be bind, volume, or tmpfs.
  *The "source" of the mount,For anonymous volumes, this field is omitted.  Can be specified as "source" or "src".i always use "src".
  *The destination takes as its value the path where the file or directory is mounted in the container.
   Can be specified as destination, dst, or target. i always go with "dst".
  *The readonly option,
  *The volume-opt option 
 
   For more option,check on docker website --> https://docs.docker.com/storage/volumes/
important  --> *Volumes used with services, only support --mount.
               *if you are mounting any directory contaning files,the existing directory are overwritten by host machin directory.
                   ex: docker run -it -v $PWD:/etc/ nginx
                       all configuration files are erased by host machine path and not able to start nginx container.
               *if you are monting empty directory,content of container directory will come and site in host machine.
               *if you are mounting file,that file in container path are overwritten by host machin file.
               *the mount directory or file have access to container user,otherwise mount will not happen and fails.
                    ex: nobody user are running inside container, directory or file have nobody user permission to read,write,execute.
commands:
      docker volume create name_of_volume
      docker volume inspect name_of_volume
      docker volume rm name_of_volume

if you give volume name otherthan host machine path,volume data will go and site in /var/lib/docker/volumes/. this is not good.

docker run -d \
  --name devtest \
  -p 8082:80 \
  --mount source=path_in_host_machine,target=/usr/share/nginx/html,readonly \
  nginx:latest

docker run -d \
  --name nginxtest \
  -p 8083:80
  -v path_in_host_machine:/usr/share/nginx/html:ro,local \
  nginx:latest

=======================================================================================================

Section5: Docker containers management

Every container are different,even if we created the container from same image. 
we can create N number containers from docker image,every container created as fresh container.

container id is a hostname for container,inside container execute hostname command,you will get the that container id.
Each container have their own ip address.

Docker doesn't care about which port you expose.All what it care about is that port must be free.
Don't use the standardly allocated ports like 25-SMTP,22-SSH,53-DNS etc.

=======================================================================================================

Section5: Running Python Application in Docker.

*Created the python file,called calendar-app.py inside python directory. written to print month of year

docker run -it -v $PWD:/app -w /app python:3-slim python calendar-app.py

option -w is used to set the working directory inside container once it is started. Passing python and python file as command to execute.

=======================================================================================================

Section6: Running Node js Application in Docker.

*created hello.js and executed that file usind node docker image.

docker run -v $PWD:/app -w /app node:slim node hello.js 

*created index.js file using some express code in express folder.
   index.js file content are taken from https://www.npmjs.com/package/express
   we need to create package.json,install the express module then we can able to start/run the index.js.
   docker run -v $PWD:/app -w /app node:slim node index.js
          node:internal/modules/cjs/loader:1051
          throw err;
          ^
          Error: Cannot find module 'express
   docker run -v $PWD:/app -w /app -it node:slim npm init  --> this will create the package.json
   docker run -v $PWD:/app -w /app -it node:slim npm install express  --> this will install express module
   docker run -v $PWD:/app -w /app -it -p 8700:3000 node:slim node index.js  --> finally node app is up,check http://localhost:8700/

   docker kill container_id_or_name -->it forcefully terminate conatiner if docker stop was not worked.
   
   Note:Every docker run command will create the conatiner,beacuse of volume mount happening to same folder,
        files are created and other container are  using that files

*Handling the SIGINT and SIGTERM in our node application.
  1)once you runned the above node app,cnt+c is not working,it is alse not responded to docker stop.used docker kill.
  now we are handling that in app only by adding process module.

  2)after below command run,press contol+c,that node app process interrupted and got terminated.
  docker run -v $PWD:/app -w /app -it -p 8700:3000 node:slim node index.js
 
  3)after below command run, do the docker stop of running container,that node app process terminated directly.
  docker run -v $PWD:/app -w /app -it -p 8700:3000 node:slim node index.js
 
*created js file to take file name,content from user and create file in files folder.
  docker run -it -v $PWD:/app -w /app node:slim node index.js
   
Conclusion -> containers can create and modify the external files,external files means files in host machine. 

=======================================================================================================


